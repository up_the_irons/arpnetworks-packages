Description: fix possible privilege escalation via pkcheck race.
Origin: backport, based on patches provided by Daniel P. Berrange <berrange@redhat.com>

Index: libvirt-0.9.8/configure.ac
===================================================================
--- libvirt-0.9.8.orig/configure.ac	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/configure.ac	2013-09-11 16:14:37.959710620 -0400
@@ -1079,6 +1079,14 @@
     AC_DEFINE_UNQUOTED([PKCHECK_PATH],["$PKCHECK_PATH"],[Location of pkcheck program])
     AC_DEFINE_UNQUOTED([HAVE_POLKIT], 1,
         [use PolicyKit for UNIX socket access checks])
+    AC_MSG_CHECKING([whether pkcheck supports uid value])
+    pkcheck_supports_uid=$($PKG_CONFIG --variable pkcheck_supports_uid polkit-gobject-1)
+    if test "x$pkcheck_supports_uid" = "xtrue"; then
+      AC_MSG_RESULT([yes])
+      AC_DEFINE_UNQUOTED([PKCHECK_SUPPORTS_UID], 1, [Pass uid to pkcheck])
+    else
+      AC_MSG_RESULT([no])
+    fi
     AC_DEFINE_UNQUOTED([HAVE_POLKIT1], 1,
         [use PolicyKit for UNIX socket access checks])
     with_polkit="yes"
Index: libvirt-0.9.8/daemon/remote.c
===================================================================
--- libvirt-0.9.8.orig/daemon/remote.c	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/daemon/remote.c	2013-09-11 16:14:37.959710620 -0400
@@ -1969,13 +1969,15 @@
     int auth = virNetServerClientGetAuth(client);
     uid_t callerUid;
     pid_t callerPid;
+    unsigned long long timestamp;
 
     /* If the client is root then we want to bypass the
      * policykit auth to avoid root being denied if
      * some piece of polkit isn't present/running
      */
     if (auth == VIR_NET_SERVER_SERVICE_AUTH_POLKIT) {
-        if (virNetServerClientGetLocalIdentity(client, &callerUid, &callerPid) < 0) {
+        if (virNetServerClientGetLocalIdentity(client, &callerUid,
+                                               &callerPid, &timestamp) < 0) {
             /* Don't do anything on error - it'll be validated at next
              * phase of auth anyway */
             virResetLastError();
@@ -2402,28 +2404,22 @@
 {
     pid_t callerPid = -1;
     uid_t callerUid = -1;
+    unsigned long long timestamp;
     const char *action;
     int status = -1;
-    char pidbuf[50];
-    char ident[100];
-    int rv = -1;
+    char *ident = NULL;
+    bool supportsuid = 0;
     struct daemonClientPrivate *priv =
         virNetServerClientGetPrivateData(client);
-
-    memset(ident, 0, sizeof ident);
+    virCommandPtr cmd = NULL;
+    static bool polkitInsecureWarned = false;
 
     virMutexLock(&priv->lock);
     action = virNetServerClientGetReadonly(client) ?
         "org.libvirt.unix.monitor" :
         "org.libvirt.unix.manage";
 
-    const char * const pkcheck [] = {
-      PKCHECK_PATH,
-      "--action-id", action,
-      "--process", pidbuf,
-      "--allow-user-interaction",
-      NULL
-    };
+    cmd = virCommandNewArgList(PKCHECK_PATH, "--action-id", action, NULL);
 
     VIR_DEBUG("Start PolicyKit auth %d", virNetServerClientGetFD(client));
     if (virNetServerClientGetAuth(client) != VIR_NET_SERVER_SERVICE_AUTH_POLKIT) {
@@ -2431,48 +2427,68 @@
         goto authfail;
     }
 
-    if (virNetServerClientGetLocalIdentity(client, &callerUid, &callerPid) < 0) {
+    if (virNetServerClientGetLocalIdentity(client, &callerUid,
+                                           &callerPid, &timestamp) < 0) {
         goto authfail;
     }
 
-    VIR_INFO("Checking PID %d running as %d", callerPid, callerUid);
-
-    rv = snprintf(pidbuf, sizeof pidbuf, "%d", callerPid);
-    if (rv < 0 || rv >= sizeof pidbuf) {
-        VIR_ERROR(_("Caller PID was too large %d"), callerPid);
+    if (timestamp == 0) {
+        VIR_WARN("Failing polkit auth due to missing client (pid=%lld) start time",
+                 (long long)callerPid);
         goto authfail;
     }
 
-    rv = snprintf(ident, sizeof ident, "pid:%d,uid:%d", callerPid, callerUid);
-    if (rv < 0 || rv >= sizeof ident) {
-        VIR_ERROR(_("Caller identity was too large %d:%d"), callerPid, callerUid);
-        goto authfail;
+    VIR_INFO("Checking PID %lld running as %d",
+             (long long) callerPid, callerUid);
+
+    virCommandAddArg(cmd, "--process");
+# ifdef PKCHECK_SUPPORTS_UID
+    supportsuid = 1;
+# endif
+    if (supportsuid) {
+        virCommandAddArgFormat(cmd, "%lld,%llu,%lu", (long long) callerPid, timestamp, (unsigned long) callerUid);
+    } else {
+        if (!polkitInsecureWarned) {
+            VIR_WARN("No support for caller UID with pkcheck. This deployment is known to be insecure.");
+            polkitInsecureWarned = true;
+        }
+        virCommandAddArgFormat(cmd, "%lld,%llu", (long long) callerPid, timestamp);
     }
+    virCommandAddArg(cmd, "--allow-user-interaction");
 
-    if (virRun(pkcheck, &status) < 0) {
-        VIR_ERROR(_("Cannot invoke %s"), PKCHECK_PATH);
+    if (virAsprintf(&ident, "pid:%lld,uid:%d",
+                    (long long) callerPid, callerUid) < 0) {
+        virReportOOMError();
         goto authfail;
     }
+
+    if (virCommandRun(cmd, &status) < 0)
+        goto authfail;
+
     if (status != 0) {
         char *tmp = virCommandTranslateStatus(status);
-        VIR_ERROR(_("Policy kit denied action %s from pid %d, uid %d: %s"),
-                  action, callerPid, callerUid, NULLSTR(tmp));
+        VIR_ERROR(_("Policy kit denied action %s from pid %lld, uid %d: %s"),
+                  action, (long long) callerPid, callerUid, NULLSTR(tmp));
         VIR_FREE(tmp);
         goto authdeny;
     }
     PROBE(RPC_SERVER_CLIENT_AUTH_ALLOW,
           "client=%p auth=%d identity=%s",
           client, REMOTE_AUTH_POLKIT, ident);
-    VIR_INFO("Policy allowed action %s from pid %d, uid %d",
-             action, callerPid, callerUid);
+    VIR_INFO("Policy allowed action %s from pid %lld, uid %d",
+             action, (long long) callerPid, callerUid);
     ret->complete = 1;
 
     virNetServerClientSetIdentity(client, ident);
     virMutexUnlock(&priv->lock);
+    virCommandFree(cmd);
+    VIR_FREE(ident);
 
     return 0;
 
 error:
+    virCommandFree(cmd);
+    VIR_FREE(ident);
     virResetLastError();
     virNetError(VIR_ERR_AUTH_FAILED, "%s",
                 _("authentication failed"));
@@ -2489,7 +2505,7 @@
 authdeny:
     PROBE(RPC_SERVER_CLIENT_AUTH_DENY,
           "client=%p auth=%d identity=%s",
-          client, REMOTE_AUTH_POLKIT, (char *)ident);
+          client, REMOTE_AUTH_POLKIT, ident);
     goto error;
 }
 #elif HAVE_POLKIT0
Index: libvirt-0.9.8/src/Makefile.am
===================================================================
--- libvirt-0.9.8.orig/src/Makefile.am	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/src/Makefile.am	2013-09-11 16:14:37.959710620 -0400
@@ -98,7 +98,9 @@
 		util/virnetdevtap.h util/virnetdevtap.c		\
 		util/virnetdevveth.h util/virnetdevveth.c \
 		util/virnetdevvportprofile.h util/virnetdevvportprofile.c \
+		util/virprocess.h util/virprocess.c		\
 		util/virsocketaddr.h util/virsocketaddr.c \
+		util/virstring.h util/virstring.c		\
 		util/virtime.h util/virtime.c
 
 EXTRA_DIST += $(srcdir)/util/virkeymaps.h $(srcdir)/util/keymaps.csv \
Index: libvirt-0.9.8/src/rpc/virnetserverclient.c
===================================================================
--- libvirt-0.9.8.orig/src/rpc/virnetserverclient.c	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/src/rpc/virnetserverclient.c	2013-09-11 16:14:37.959710620 -0400
@@ -448,12 +448,13 @@
 }
 
 int virNetServerClientGetLocalIdentity(virNetServerClientPtr client,
-                                       uid_t *uid, pid_t *pid)
+                                      uid_t *uid, pid_t *pid,
+                                      unsigned long long *timestamp)
 {
     int ret = -1;
     virNetServerClientLock(client);
     if (client->sock)
-        ret = virNetSocketGetLocalIdentity(client->sock, uid, pid);
+        ret = virNetSocketGetLocalIdentity(client->sock, uid, pid, timestamp);
     virNetServerClientUnlock(client);
     return ret;
 }
Index: libvirt-0.9.8/src/rpc/virnetserverclient.h
===================================================================
--- libvirt-0.9.8.orig/src/rpc/virnetserverclient.h	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/src/rpc/virnetserverclient.h	2013-09-11 16:14:37.959710620 -0400
@@ -71,7 +71,8 @@
 const char *virNetServerClientGetIdentity(virNetServerClientPtr client);
 
 int virNetServerClientGetLocalIdentity(virNetServerClientPtr client,
-                                       uid_t *uid, pid_t *pid);
+                                       uid_t *uid, pid_t *pid,
+                                       unsigned long long *timestamp);
 
 void virNetServerClientRef(virNetServerClientPtr client);
 
Index: libvirt-0.9.8/src/rpc/virnetsocket.c
===================================================================
--- libvirt-0.9.8.orig/src/rpc/virnetsocket.c	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/src/rpc/virnetsocket.c	2013-09-11 16:14:37.959710620 -0400
@@ -43,6 +43,7 @@
 #include "virfile.h"
 #include "event.h"
 #include "threads.h"
+#include "virprocess.h"
 
 #include "passfd.h"
 
@@ -826,29 +827,38 @@
 #ifdef SO_PEERCRED
 int virNetSocketGetLocalIdentity(virNetSocketPtr sock,
                                  uid_t *uid,
-                                 pid_t *pid)
+                                pid_t *pid,
+                                unsigned long long *timestamp)
 {
     struct ucred cr;
     socklen_t cr_len = sizeof (cr);
+    int ret = -1;
+
     virMutexLock(&sock->lock);
 
     if (getsockopt(sock->fd, SOL_SOCKET, SO_PEERCRED, &cr, &cr_len) < 0) {
         virReportSystemError(errno, "%s",
                              _("Failed to get client socket identity"));
-        virMutexUnlock(&sock->lock);
-        return -1;
+        goto cleanup;
     }
 
+    if (virProcessGetStartTime(cr.pid, timestamp) < 0)
+        goto cleanup;
+
     *pid = cr.pid;
     *uid = cr.uid;
 
+    ret = 0;
+
+cleanup:
     virMutexUnlock(&sock->lock);
-    return 0;
+    return ret;
 }
 #else
 int virNetSocketGetLocalIdentity(virNetSocketPtr sock ATTRIBUTE_UNUSED,
                                  uid_t *uid ATTRIBUTE_UNUSED,
-                                 pid_t *pid ATTRIBUTE_UNUSED)
+                                pid_t *pid ATTRIBUTE_UNUSED,
+                                unsigned long long *timestamp ATTRIBUTE_UNUSED)
 {
     /* XXX Many more OS support UNIX socket credentials we could port to. See dbus ....*/
     virReportSystemError(ENOSYS, "%s",
Index: libvirt-0.9.8/src/rpc/virnetsocket.h
===================================================================
--- libvirt-0.9.8.orig/src/rpc/virnetsocket.h	2013-09-11 16:14:37.963710620 -0400
+++ libvirt-0.9.8/src/rpc/virnetsocket.h	2013-09-11 16:14:37.959710620 -0400
@@ -88,7 +88,8 @@
 
 int virNetSocketGetLocalIdentity(virNetSocketPtr sock,
                                  uid_t *uid,
-                                 pid_t *pid);
+                                 pid_t *pid,
+                                 unsigned long long *timestamp);
 
 int virNetSocketSetBlocking(virNetSocketPtr sock,
                             bool blocking);
Index: libvirt-0.9.8/src/util/virprocess.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.9.8/src/util/virprocess.c	2013-09-11 19:51:34.151426866 -0400
@@ -0,0 +1,161 @@
+/*
+ * virprocess.c: interaction with processes
+ *
+ * Copyright (C) 2010-2013 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ */
+
+
+#include <config.h>
+
+#include <dirent.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <errno.h>
+#include <sys/wait.h>
+#if HAVE_SETRLIMIT
+# include <sys/time.h>
+# include <sys/resource.h>
+#endif
+#include <sched.h>
+
+#ifdef __FreeBSD__
+# include <sys/param.h>
+# include <sys/sysctl.h>
+# include <sys/user.h>
+#endif
+
+#include "virprocess.h"
+#include "virterror_internal.h"
+#include "memory.h"
+#include "util.h"
+#include "virstring.h"
+
+#define VIR_FROM_THIS VIR_FROM_NONE
+
+#define virProcessError(code, ...)                                      \
+    virReportErrorHelper(VIR_FROM_NONE, code, __FILE__,                 \
+                         __FUNCTION__, __LINE__, __VA_ARGS__)
+
+#ifdef __linux__
+/*
+ * Port of code from polkitunixprocess.c under terms
+ * of the LGPLv2+
+ */
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    char *filename = NULL;
+    char *buf = NULL;
+    char *tmp;
+    int ret = -1;
+    int len;
+    char **tokens = NULL;
+
+    if (virAsprintf(&filename, "/proc/%llu/stat",
+                    (unsigned long long)pid) < 0) {
+        virReportOOMError();
+        return -1;
+    }
+
+    if ((len = virFileReadAll(filename, 1024, &buf)) < 0)
+        goto cleanup;
+
+    /* start time is the token at index 19 after the '(process name)' entry - since only this
+     * field can contain the ')' character, search backwards for this to avoid malicious
+     * processes trying to fool us
+     */
+
+    if (!(tmp = strrchr(buf, ')'))) {
+        virProcessError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+    tmp += 2; /* skip ') ' */
+    if ((tmp - buf) >= len) {
+        virProcessError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+
+    tokens = virStringSplit(tmp, " ", 0);
+
+    if (virStringListLength(tokens) < 20) {
+        virProcessError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot find start time in %s"),
+                       filename);
+        goto cleanup;
+    }
+
+    if (virStrToLong_ull(tokens[19],
+                         NULL,
+                         10,
+                         timestamp) < 0) {
+        virProcessError(VIR_ERR_INTERNAL_ERROR,
+                       _("Cannot parse start time %s in %s"),
+                       tokens[19], filename);
+        goto cleanup;
+    }
+
+    ret = 0;
+
+cleanup:
+    virStringFreeList(tokens);
+    VIR_FREE(filename);
+    VIR_FREE(buf);
+    return ret;
+}
+#elif defined(__FreeBSD__)
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    struct kinfo_proc p;
+    int mib[4];
+    size_t len = 4;
+
+    sysctlnametomib("kern.proc.pid", mib, &len);
+
+    len = sizeof(struct kinfo_proc);
+    mib[3] = pid;
+
+    if (sysctl(mib, 4, &p, &len, NULL, 0) < 0) {
+        virReportSystemError(errno, "%s",
+                             _("Unable to query process ID start time"));
+        return -1;
+    }
+
+    *timestamp = (unsigned long long)p.ki_start.tv_sec;
+
+    return 0;
+
+}
+#else
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp)
+{
+    static int warned = 0;
+    if (virAtomicIntInc(&warned) == 1) {
+        VIR_WARN("Process start time of pid %llu not available on this platform",
+                 (unsigned long long)pid);
+        warned = true;
+    }
+    *timestamp = 0;
+    return 0;
+}
+#endif
Index: libvirt-0.9.8/src/util/virprocess.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.9.8/src/util/virprocess.h	2013-09-11 16:14:37.959710620 -0400
@@ -0,0 +1,32 @@
+/*
+ * virprocess.h: interaction with processes
+ *
+ * Copyright (C) 2010-2013 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef __VIR_PROCESS_H__
+# define __VIR_PROCESS_H__
+
+# include <sys/types.h>
+
+# include "internal.h"
+
+int virProcessGetStartTime(pid_t pid,
+                           unsigned long long *timestamp);
+
+#endif /* __VIR_PROCESS_H__ */
Index: libvirt-0.9.8/src/util/virstring.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.9.8/src/util/virstring.c	2013-09-11 16:14:37.959710620 -0400
@@ -0,0 +1,182 @@
+/*
+ * Copyright (C) 2012 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Authors:
+ *     Daniel P. Berrange <berrange@redhat.com>
+ */
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "c-ctype.h"
+#include "virstring.h"
+#include "memory.h"
+#include "buf.h"
+#include "virterror_internal.h"
+
+#define VIR_FROM_THIS VIR_FROM_NONE
+
+/*
+ * The following virStringSplit & virStringJoin methods
+ * are derived from g_strsplit / g_strjoin in glib2,
+ * also available under the LGPLv2+ license terms
+ */
+
+/**
+ * virStringSplit:
+ * @string: a string to split
+ * @delim: a string which specifies the places at which to split
+ *     the string. The delimiter is not included in any of the resulting
+ *     strings, unless @max_tokens is reached.
+ * @max_tokens: the maximum number of pieces to split @string into.
+ *     If this is 0, the string is split completely.
+ *
+ * Splits a string into a maximum of @max_tokens pieces, using the given
+ * @delim. If @max_tokens is reached, the remainder of @string is
+ * appended to the last token.
+ *
+ * As a special case, the result of splitting the empty string "" is an empty
+ * vector, not a vector containing a single string. The reason for this
+ * special case is that being able to represent a empty vector is typically
+ * more useful than consistent handling of empty elements. If you do need
+ * to represent empty elements, you'll need to check for the empty string
+ * before calling virStringSplit().
+ *
+ * Return value: a newly-allocated NULL-terminated array of strings. Use
+ *    virStringFreeList() to free it.
+ */
+char **virStringSplit(const char *string,
+                      const char *delim,
+                      size_t max_tokens)
+{
+    char **tokens = NULL;
+    size_t ntokens = 0;
+    size_t maxtokens = 0;
+    const char *remainder = string;
+    char *tmp;
+    size_t i;
+
+    if (max_tokens == 0)
+        max_tokens = INT_MAX;
+
+    tmp = strstr(remainder, delim);
+    if (tmp) {
+        size_t delimlen = strlen(delim);
+
+        while (--max_tokens && tmp) {
+            size_t len = tmp - remainder;
+
+            if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)
+                goto no_memory;
+
+            if (!(tokens[ntokens] = strndup(remainder, len)))
+                goto no_memory;
+            ntokens++;
+            remainder = tmp + delimlen;
+            tmp = strstr(remainder, delim);
+        }
+    }
+    if (*string) {
+        if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)
+            goto no_memory;
+
+        if (!(tokens[ntokens] = strdup(remainder)))
+            goto no_memory;
+        ntokens++;
+    }
+
+    if (VIR_RESIZE_N(tokens, maxtokens, ntokens, 1) < 0)
+        goto no_memory;
+    tokens[ntokens++] = NULL;
+
+    return tokens;
+
+no_memory:
+    virReportOOMError();
+    for (i = 0 ; i < ntokens ; i++)
+        VIR_FREE(tokens[i]);
+    VIR_FREE(tokens);
+    return NULL;
+}
+
+
+/**
+ * virStringJoin:
+ * @strings: a NULL-terminated array of strings to join
+ * @delim: a string to insert between each of the strings
+ *
+ * Joins a number of strings together to form one long string, with the
+ * @delim inserted between each of them. The returned string
+ * should be freed with VIR_FREE().
+ *
+ * Returns: a newly-allocated string containing all of the strings joined
+ *     together, with @delim between them
+ */
+char *virStringJoin(const char **strings,
+                    const char *delim)
+{
+    char *ret;
+    virBuffer buf = VIR_BUFFER_INITIALIZER;
+    while (*strings) {
+        virBufferAdd(&buf, *strings, -1);
+        if (*(strings+1))
+            virBufferAdd(&buf, delim, -1);
+        strings++;
+    }
+    if (virBufferError(&buf)) {
+        virReportOOMError();
+        return NULL;
+    }
+    ret = virBufferContentAndReset(&buf);
+    if (!ret) {
+        if (!(ret = strdup(""))) {
+            virReportOOMError();
+            return NULL;
+        }
+    }
+    return ret;
+}
+
+
+/**
+ * virStringFreeList:
+ * @str_array: a NULL-terminated array of strings to free
+ *
+ * Frees a NULL-terminated array of strings, and the array itself.
+ * If called on a NULL value, virStringFreeList() simply returns.
+ */
+void virStringFreeList(char **strings)
+{
+    char **tmp = strings;
+    while (tmp && *tmp) {
+        VIR_FREE(*tmp);
+        tmp++;
+    }
+    VIR_FREE(strings);
+}
+
+size_t virStringListLength(char **strings)
+{
+    size_t i = 0;
+
+    while (strings && strings[i])
+        i++;
+
+    return i;
+}
Index: libvirt-0.9.8/src/util/virstring.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libvirt-0.9.8/src/util/virstring.h	2013-09-11 16:14:37.959710620 -0400
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2007-2012 Red Hat, Inc.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * Authors:
+ *     Daniel P. Berrange <berrange@redhat.com>
+ */
+
+#ifndef __VIR_STRING_H__
+# define __VIR_STRING_H__
+
+# include <stdarg.h>
+
+# include "internal.h"
+
+char **virStringSplit(const char *string,
+                      const char *delim,
+                      size_t max_tokens)
+    ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2);
+
+char *virStringJoin(const char **strings,
+                    const char *delim);
+
+void virStringFreeList(char **strings);
+
+size_t virStringListLength(char **strings);
+
+#endif /* __VIR_STRING_H__ */
